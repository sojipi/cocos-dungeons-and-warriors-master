<!DOCTYPE html>
<html>
<head>
    <title>随机迷宫生成器测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .maze {
            display: grid;
            gap: 1px;
            background-color: #ccc;
            margin: 20px 0;
        }
        .cell {
            width: 20px;
            height: 20px;
            background-color: #fff;
        }
        .wall {
            background-color: #000;
        }
        .floor {
            background-color: #fff;
        }
        .start {
            background-color: #0f0;
        }
        .end {
            background-color: #f00;
        }
    </style>
</head>
<body>
    <h1>随机迷宫生成器测试</h1>
    <div id="maze-container"></div>

    <script>
        // 迷宫配置
        const config = {
            width: 15,
            height: 15,
            cellSize: 20
        };

        // 生成迷宫
        const maze = generateMaze(config.width, config.height);

        // 渲染迷宫
        renderMaze(maze, config);

        // 深度优先搜索迷宫生成算法
        function generateMaze(width, height) {
            // 初始化迷宫，所有单元格都是墙壁
            const maze = Array(height).fill().map(() => Array(width).fill(1));
            const stack = [];
            const startX = 0;
            const startY = 0;

            // 标记起点
            maze[startY][startX] = 0;
            stack.push([startX, startY]);

            // 方向：上、右、下、左
            const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const neighbors = [];

                // 检查所有方向的邻居
                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && maze[ny][nx] === 1) {
                        neighbors.push([nx, ny, dx, dy]);
                    }
                }

                if (neighbors.length > 0) {
                    stack.push([x, y]);
                    const [nx, ny, dx, dy] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[ny][nx] = 0;
                    maze[y + dy / 2][x + dx / 2] = 0;
                    stack.push([nx, ny]);
                }
            }

            // 标记终点
            maze[height - 1][width - 1] = 0;

            return maze;
        }

        // 渲染迷宫
        function renderMaze(maze, config) {
            const container = document.getElementById('maze-container');
            container.style.gridTemplateColumns = `repeat(${config.width}, ${config.cellSize}px)`;

            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.width = `${config.cellSize}px`;
                    cell.style.height = `${config.cellSize}px`;

                    if (maze[y][x] === 1) {
                        cell.classList.add('wall');
                    } else if (x === 0 && y === 0) {
                        cell.classList.add('start');
                    } else if (x === maze[y].length - 1 && y === maze.length - 1) {
                        cell.classList.add('end');
                    } else {
                        cell.classList.add('floor');
                    }

                    container.appendChild(cell);
                }
            }
        }
    </script>
</body>
</html>